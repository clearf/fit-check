"""Tests for Garmin API response normalizer.

Fixtures are captured from the real Garmin API using:
    python scripts/capture_fixtures.py

Re-run this script periodically (or after garminconnect upgrades) to ensure
the fixtures reflect the actual API response schema.

Schema notes captured from real API responses:

  get_activity_evaluation() → garmin_activity_summary.json:
    - activityTypeDTO (not activityType)
    - summaryDTO nests: startTimeGMT, startTimeLocal, duration, distance,
      averageHR, maxHR, averageSpeed, elevationGain, elevationLoss,
      trainingEffect, anaerobicTrainingEffect, averageRunCadence
    - Time format: "YYYY-MM-DDTHH:MM:SS.f" (ISO 8601 with T separator)
    - vO2MaxValue NOT present (only in get_activities() list items)

  get_activities() → garmin_activity_list_item.json:
    - activityType (not activityTypeDTO), flat structure
    - startTimeGMT, startTimeLocal at top level
    - Time format: "YYYY-MM-DD HH:MM:SS" (space-separated)
    - vO2MaxValue present at top level

  get_activity_splits() → garmin_activity_splits.json:
    - {"lapDTOs": [...]}  (top-level wrapper)
    - Each lapDTO: intensityType (WARMUP/ACTIVE/RECOVERY/COOLDOWN)
    - Fields: distance, duration, averageHR, averageSpeed, elevationGain
    - startTimeGMT is ISO 8601 absolute timestamp (not elapsed seconds)
"""
import json
from datetime import date, datetime
from pathlib import Path

import pytest

from fitness.garmin.normalizer import (
    normalize_activity_summary,
    normalize_sleep,
    normalize_hrv,
    normalize_typed_split,
    build_step_target_map,
)

FIXTURES = Path(__file__).parent.parent / "fixtures"


@pytest.fixture
def activity_summary():
    """Real response from get_activity_evaluation() — nested summaryDTO schema.

    Key differences from get_activities() list items:
    - activityTypeDTO (not activityType)
    - summaryDTO wraps performance data
    - ISO 8601 time format with T separator
    - vO2MaxValue not present
    """
    return json.loads((FIXTURES / "garmin_activity_summary.json").read_text())


@pytest.fixture
def activity_list_item():
    """Real response item from get_activities() list — flat schema.

    Generated by scripts/capture_fixtures.py. If the file is absent, these
    tests are skipped (run the capture script to generate it).
    """
    p = FIXTURES / "garmin_activity_list_item.json"
    if not p.exists():
        pytest.skip("garmin_activity_list_item.json not found — run scripts/capture_fixtures.py")
    return json.loads(p.read_text())


@pytest.fixture
def sleep_data():
    return json.loads((FIXTURES / "garmin_sleep.json").read_text())


@pytest.fixture
def hrv_data():
    return json.loads((FIXTURES / "garmin_hrv.json").read_text())


@pytest.fixture
def typed_splits():
    """Real lapDTOs from get_activity_splits() if available, else hand-crafted."""
    real = FIXTURES / "garmin_activity_splits.json"
    if real.exists():
        data = json.loads(real.read_text())
        # get_activity_splits returns {"lapDTOs": [...]}
        laps = data.get("lapDTOs", data) if isinstance(data, dict) else data
        return laps
    return json.loads((FIXTURES / "garmin_typed_splits.json").read_text())


# ─── Activity summary normalizer (get_activity_evaluation schema) ──────────────

class TestNormalizeActivitySummary:
    """Tests against real get_activity_evaluation() fixture (nested summaryDTO schema)."""

    def test_returns_dict(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        assert isinstance(result, dict)

    def test_garmin_activity_id_is_string(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # scrubbed fixture uses activityId 10000000001
        assert result["garmin_activity_id"] == "10000000001"

    def test_name_extracted(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # scrubbed fixture uses "Seattle - Speed Repeats"
        assert result["name"] == "Seattle - Speed Repeats"

    def test_activity_type_extracted(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # activityTypeDTO.typeKey = "running" in real fixture
        assert result["activity_type"] == "running"

    def test_start_time_is_datetime(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        assert isinstance(result["start_time_utc"], datetime)
        # summaryDTO.startTimeGMT = "2026-02-18T19:22:38.0"
        assert result["start_time_utc"].year == 2026
        assert result["start_time_utc"].hour == 19
        assert result["start_time_utc"].minute == 22

    def test_duration_seconds(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # summaryDTO.duration = 4313.975
        assert result["duration_seconds"] == pytest.approx(4313.975)

    def test_distance_meters(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # summaryDTO.distance = 10551.31
        assert result["distance_meters"] == pytest.approx(10551.31)

    def test_avg_hr(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # summaryDTO.averageHR = 133.0
        assert result["avg_hr"] == pytest.approx(133.0)

    def test_max_hr(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # summaryDTO.maxHR = 170.0
        assert result["max_hr"] == pytest.approx(170.0)

    def test_avg_pace_derived_from_speed(self, activity_summary):
        # summaryDTO.averageSpeed = 2.446000099 m/s → pace = 1000/2.446 ≈ 408.9 s/km
        result = normalize_activity_summary(activity_summary)
        assert result["avg_pace_seconds_per_km"] == pytest.approx(1000.0 / 2.446000099182129, abs=1.0)

    def test_elevation_gain_and_loss(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # summaryDTO.elevationGain = 15.48, elevationLoss = 16.23
        assert result["total_ascent_meters"] == pytest.approx(15.48)
        assert result["total_descent_meters"] == pytest.approx(16.23)

    def test_training_effect(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # summaryDTO.trainingEffect = 4.1 (aerobic), anaerobicTrainingEffect = 0.1
        assert result["training_effect_aerobic"] == pytest.approx(4.1, abs=0.01)
        assert result["training_effect_anaerobic"] == pytest.approx(0.1, abs=0.01)

    def test_vo2max_is_none_for_evaluation_endpoint(self, activity_summary):
        """vO2MaxValue is only in get_activities() list items, not evaluation responses."""
        result = normalize_activity_summary(activity_summary)
        assert result["vo2max_estimated"] is None

    def test_weather_temp_is_none_when_absent(self, activity_summary):
        """Real fixture has no weatherTemperature field."""
        result = normalize_activity_summary(activity_summary)
        assert result["weather_temp_c"] is None

    def test_raw_summary_json_stored(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        stored = json.loads(result["raw_summary_json"])
        assert stored["activityId"] == activity_summary["activityId"]

    def test_missing_optional_fields_are_none(self):
        """Minimal flat dict (hand-crafted) — optional fields should be None."""
        minimal = {
            "activityId": 999,
            "activityName": "Run",
            "activityType": {"typeKey": "running"},
            "startTimeGMT": "2025-06-01 08:00:00",
            "duration": 1800.0,
            "distance": 5000.0,
        }
        result = normalize_activity_summary(minimal)
        assert result["avg_hr"] is None
        assert result["vo2max_estimated"] is None
        assert result["training_effect_aerobic"] is None
        assert result["weather_temp_c"] is None

    def test_start_time_from_startTimeLocal_when_startTimeGMT_absent(self):
        """get_activity_evaluation() returns startTimeLocal (nested in summaryDTO).

        The normalizer must handle both key names so that both get_activities()
        list items (startTimeGMT) and get_activity_evaluation() detail objects
        (startTimeLocal) can be normalised without KeyError.
        """
        raw = {
            "activityId": 999,
            "activityName": "Evening Run",
            "activityType": {"typeKey": "running"},
            "startTimeLocal": "2025-06-01 20:00:00",  # key from list endpoint
            "duration": 1800.0,
            "distance": 5000.0,
        }
        result = normalize_activity_summary(raw)
        assert isinstance(result["start_time_utc"], datetime)
        assert result["start_time_utc"].hour == 20

    def test_start_time_from_summaryDTO_startTimeLocal(self):
        """get_activity_evaluation() nests startTimeLocal inside summaryDTO."""
        raw = {
            "activityId": 999,
            "activityName": "Evening Run",
            "activityTypeDTO": {"typeKey": "running"},
            "summaryDTO": {
                "startTimeLocal": "2025-06-01T20:00:00.0",  # ISO 8601, nested
                "duration": 1800.0,
                "distance": 5000.0,
            },
        }
        result = normalize_activity_summary(raw)
        assert isinstance(result["start_time_utc"], datetime)
        assert result["start_time_utc"].hour == 20

    def test_start_time_prefers_startTimeGMT_over_startTimeLocal(self):
        """When both keys exist, startTimeGMT (true UTC) takes precedence."""
        raw = {
            "activityId": 999,
            "activityName": "Morning Run",
            "activityType": {"typeKey": "running"},
            "startTimeGMT": "2025-06-01 07:00:00",
            "startTimeLocal": "2025-06-01 09:00:00",  # local offset, should be ignored
            "duration": 1800.0,
            "distance": 5000.0,
        }
        result = normalize_activity_summary(raw)
        assert result["start_time_utc"].hour == 7

    def test_raises_key_error_when_neither_start_time_key_present(self):
        """Confirm a clear error when the response has no recognisable time field."""
        raw = {
            "activityId": 999,
            "activityName": "Run",
            "activityType": {"typeKey": "running"},
            "duration": 1800.0,
            "distance": 5000.0,
        }
        with pytest.raises(KeyError):
            normalize_activity_summary(raw)

    def test_iso_8601_datetime_parsed_correctly(self):
        """ISO 8601 format from get_activity_evaluation() is parsed correctly."""
        raw = {
            "activityId": 999,
            "activityName": "Run",
            "activityTypeDTO": {"typeKey": "running"},
            "summaryDTO": {
                "startTimeGMT": "2025-06-01T14:30:00.0",
                "duration": 1800.0,
                "distance": 5000.0,
            },
        }
        result = normalize_activity_summary(raw)
        assert result["start_time_utc"] == datetime(2025, 6, 1, 14, 30, 0)


# ─── Activity list item normalizer (uses startTimeGMT schema) ─────────────────

class TestNormalizeActivityListItem:
    """Tests against real get_activities() list item fixture (startTimeGMT schema).

    These tests are skipped if the fixture hasn't been captured yet.
    Run: python scripts/capture_fixtures.py
    """

    def test_returns_dict(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert isinstance(result, dict)

    def test_garmin_activity_id_is_string(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert isinstance(result["garmin_activity_id"], str)
        assert len(result["garmin_activity_id"]) > 0

    def test_activity_type_extracted(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert result["activity_type"] == "running"

    def test_start_time_is_datetime(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert isinstance(result["start_time_utc"], datetime)

    def test_start_time_uses_gmt_not_local(self, activity_list_item):
        """List items have both startTimeGMT and startTimeLocal; GMT should be used."""
        result = normalize_activity_summary(activity_list_item)
        # scrubbed fixture: startTimeGMT = "2026-02-18 19:22:38" (hour=19)
        # scrubbed fixture: startTimeLocal = "2026-02-18 11:22:38" (hour=11)
        assert result["start_time_utc"].hour == 19

    def test_duration_is_float(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert isinstance(result["duration_seconds"], float)
        assert result["duration_seconds"] > 0

    def test_distance_is_float(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert isinstance(result["distance_meters"], float)
        assert result["distance_meters"] > 0

    def test_vo2max_present_in_list_items(self, activity_list_item):
        """vO2MaxValue is present in get_activities() list items."""
        result = normalize_activity_summary(activity_list_item)
        # scrubbed fixture has vO2MaxValue = 46.0
        assert result["vo2max_estimated"] == pytest.approx(46.0)

    def test_avg_hr_extracted(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert result["avg_hr"] is not None
        assert result["avg_hr"] > 0

    def test_raw_json_round_trips(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        stored = json.loads(result["raw_summary_json"])
        assert stored["activityId"] == activity_list_item["activityId"]


# ─── Sleep normalizer ──────────────────────────────────────────────────────────

class TestNormalizeSleep:
    def test_returns_dict(self, sleep_data):
        result = normalize_sleep(sleep_data)
        assert isinstance(result, dict)

    def test_sleep_date_is_date(self, sleep_data):
        result = normalize_sleep(sleep_data)
        assert isinstance(result["sleep_date"], date)
        # real fixture: calendarDate = "2026-02-19"
        assert result["sleep_date"] == date(2026, 2, 19)

    def test_duration_seconds(self, sleep_data):
        result = normalize_sleep(sleep_data)
        # real fixture: sleepTimeSeconds = 26280
        assert result["duration_seconds"] == 26280

    def test_sleep_stages(self, sleep_data):
        result = normalize_sleep(sleep_data)
        # real fixture values
        assert result["deep_sleep_seconds"] == 6720
        assert result["light_sleep_seconds"] == 14100
        assert result["rem_sleep_seconds"] == 5460
        assert result["awake_seconds"] == 2340

    def test_sleep_score_is_none_when_absent(self, sleep_data):
        """Real fixture has sleepScores: null — score should be None."""
        result = normalize_sleep(sleep_data)
        assert result["sleep_score"] is None

    def test_raw_json_stored(self, sleep_data):
        result = normalize_sleep(sleep_data)
        assert result["raw_json"] is not None
        stored = json.loads(result["raw_json"])
        assert "dailySleepDTO" in stored

    def test_sleep_score_extracted_when_nested(self):
        """When sleepScores.overall.value is present, it should be extracted."""
        raw = {
            "dailySleepDTO": {
                "calendarDate": "2025-01-15",
                "sleepTimeSeconds": 24000,
                "deepSleepSeconds": 4200,
                "lightSleepSeconds": 10800,
                "remSleepSeconds": 7200,
                "awakeSleepSeconds": 1800,
                "sleepScores": {"overall": {"value": 71}},
                "averageSpO2Value": 96.5,
            }
        }
        result = normalize_sleep(raw)
        assert result["sleep_score"] == 71
        assert result["avg_spo2"] == pytest.approx(96.5)
        assert result["sleep_date"] == date(2025, 1, 15)
        assert result["duration_seconds"] == 24000
        assert result["deep_sleep_seconds"] == 4200
        assert result["light_sleep_seconds"] == 10800
        assert result["rem_sleep_seconds"] == 7200
        assert result["awake_seconds"] == 1800


# ─── HRV normalizer ───────────────────────────────────────────────────────────

class TestNormalizeHRV:
    """HRV fixture may be null (no data captured). Tests use hand-crafted data."""

    def test_returns_dict(self):
        raw = {
            "hrvSummary": {
                "startTimestampGMT": "2025-01-15T08:00:00",
                "weeklyAvg": 58.0,
                "lastNight": 52.0,
                "status": "BALANCED",
            }
        }
        result = normalize_hrv(raw)
        assert isinstance(result, dict)

    def test_record_date(self):
        raw = {
            "hrvSummary": {
                "startTimestampGMT": "2025-01-15T08:00:00",
                "weeklyAvg": 58.0,
                "lastNight": 52.0,
                "status": "BALANCED",
            }
        }
        result = normalize_hrv(raw)
        assert isinstance(result["record_date"], date)
        assert result["record_date"] == date(2025, 1, 15)

    def test_weekly_avg_hrv(self):
        raw = {
            "hrvSummary": {
                "startTimestampGMT": "2025-01-15T08:00:00",
                "weeklyAvg": 58.0,
                "lastNight": 52.0,
                "status": "BALANCED",
            }
        }
        result = normalize_hrv(raw)
        assert result["weekly_avg_hrv"] == pytest.approx(58.0)

    def test_last_night_hrv(self):
        raw = {
            "hrvSummary": {
                "startTimestampGMT": "2025-01-15T08:00:00",
                "weeklyAvg": 58.0,
                "lastNight": 52.0,
                "status": "BALANCED",
            }
        }
        result = normalize_hrv(raw)
        assert result["last_night_avg_hrv"] == pytest.approx(52.0)

    def test_status(self):
        raw = {
            "hrvSummary": {
                "startTimestampGMT": "2025-01-15T08:00:00",
                "weeklyAvg": 58.0,
                "lastNight": 52.0,
                "status": "BALANCED",
            }
        }
        result = normalize_hrv(raw)
        assert result["status"] == "BALANCED"

    def test_raw_json_stored(self):
        raw = {
            "hrvSummary": {
                "startTimestampGMT": "2025-01-15T08:00:00",
                "weeklyAvg": 58.0,
                "lastNight": 52.0,
                "status": "BALANCED",
            }
        }
        result = normalize_hrv(raw)
        assert result["raw_json"] is not None


# ─── Typed split normalizer (real lapDTOs schema) ─────────────────────────────

class TestNormalizeTypedSplit:
    """Tests against real lapDTOs from get_activity_splits().

    Real fixture schema (lapDTOs):
      - intensityType: "WARMUP" | "ACTIVE" | "RECOVERY" | "COOLDOWN"
      - laps[0]: WARMUP   → split_type "run_segment"
      - laps[1]: ACTIVE   → split_type "run_segment"
      - laps[3]: RECOVERY → split_type "walk_segment"
      - Fields: distance, duration, averageHR, averageSpeed, elevationGain
      - startTimeGMT: ISO 8601 absolute timestamp (elapsed computed by caller)

    Note: split_type mapping preserves Garmin intensityType:
      ACTIVE → run_segment
      RECOVERY → walk_segment
      WARMUP → warmup_segment  (distinct so labeler assigns "Warmup" reliably)
      COOLDOWN → cooldown_segment  (distinct so labeler assigns "Cooldown" reliably)
    """

    def test_warmup_maps_to_warmup_segment(self, typed_splits):
        """laps[0] is WARMUP → warmup_segment (distinct from run_segment)."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        assert result["split_type"] == "warmup_segment"

    def test_active_maps_to_run_segment(self, typed_splits):
        """laps[1] is ACTIVE → run_segment."""
        result = normalize_typed_split(typed_splits[1], split_index=1)
        assert result["split_type"] == "run_segment"

    def test_recovery_maps_to_walk_segment(self, typed_splits):
        """laps[3] is RECOVERY → walk_segment."""
        result = normalize_typed_split(typed_splits[3], split_index=3)
        assert result["split_type"] == "walk_segment"

    def test_split_index(self, typed_splits):
        result = normalize_typed_split(typed_splits[0], split_index=0)
        assert result["split_index"] == 0

    def test_split_index_preserved(self, typed_splits):
        result = normalize_typed_split(typed_splits[3], split_index=3)
        assert result["split_index"] == 3

    def test_duration_seconds_warmup(self, typed_splits):
        """laps[0] WARMUP duration = 300.0 seconds."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        assert result["duration_seconds"] == pytest.approx(300.0)

    def test_distance_meters_warmup(self, typed_splits):
        """laps[0] WARMUP distance = 832.69 meters."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        assert result["distance_meters"] == pytest.approx(832.69, abs=0.1)

    def test_avg_hr_warmup(self, typed_splits):
        """laps[0] WARMUP averageHR = 127.0."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        assert result["avg_hr"] == pytest.approx(127.0)

    def test_avg_pace_derived_from_speed(self, typed_splits):
        """laps[0] WARMUP averageSpeed ≈ 2.776 m/s → pace ≈ 360 s/km."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        # 1000 / 2.776 ≈ 360.2 s/km
        assert result["avg_pace_seconds_per_km"] == pytest.approx(360.2, abs=2.0)

    def test_elevation_gain_extracted(self, typed_splits):
        """elevationGain is stored in total_ascent_meters when present."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        # warmup lap has elevationGain field
        assert "total_ascent_meters" in result

    def test_start_elapsed_seconds_zero_without_activity_start(self, typed_splits):
        """normalize_typed_split doesn't know activity start time.

        start_elapsed_seconds will be 0 unless a startTime field is present
        in the lapDTO (it's not in real lapDTOs — the caller must derive it
        from startTimeGMT vs activity startTimeGMT).
        """
        result = normalize_typed_split(typed_splits[0], split_index=0)
        assert result["start_elapsed_seconds"] == 0

    def test_unknown_intensity_maps_to_lap(self, typed_splits):
        """Unrecognised intensityType falls back to 'lap'."""
        raw = dict(typed_splits[0])
        raw["intensityType"] = "UNKNOWN_TYPE"
        result = normalize_typed_split(raw, split_index=99)
        assert result["split_type"] == "lap"

    def test_all_required_keys_present(self, typed_splits):
        """Normalizer always returns all required ActivitySplit field keys."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        required_keys = {
            "split_index",
            "split_type",
            "start_elapsed_seconds",
            "duration_seconds",
            "distance_meters",
            "avg_hr",
            "avg_pace_seconds_per_km",
            "total_ascent_meters",
        }
        assert required_keys.issubset(result.keys())

    def test_wkt_step_index_extracted_when_present(self, typed_splits):
        """wktStepIndex from lapDTO is stored as wkt_step_index."""
        # Real fixture laps[0] has wktStepIndex=0
        result = normalize_typed_split(typed_splits[0], split_index=0)
        assert result["wkt_step_index"] == 0

    def test_wkt_step_index_none_when_absent(self):
        """Laps without wktStepIndex (e.g. unstructured runs) return None."""
        raw = {"intensityType": "ACTIVE", "distance": 800.0, "duration": 227.0,
               "averageHR": 160.0, "averageSpeed": 3.5}
        result = normalize_typed_split(raw, split_index=0)
        assert result["wkt_step_index"] is None

    def test_wkt_step_index_for_speed_interval(self, typed_splits):
        """laps[16] is the first 800m speed interval — wktStepIndex=9."""
        # lap index 16 (0-based) = lapIndex 17 in fixture
        result = normalize_typed_split(typed_splits[16], split_index=16)
        assert result["wkt_step_index"] == 9


# ─── Workout step target map ──────────────────────────────────────────────────

@pytest.fixture
def workout_def():
    """Real Garmin workout definition from /workout-service/workout/{id}."""
    return json.loads((FIXTURES / "garmin_workout.json").read_text())


class TestBuildStepTargetMap:
    """Tests for build_step_target_map() using the real garmin_workout.json fixture.

    The fixture is "Speed Repeats" workout (workoutId=1467965958):
      stepOrder=1  (wktStepIndex=0):  WARMUP, 5min, no target
      stepOrder=2  (wktStepIndex=1):  other, "Up next: Cadence Drill", lap.button
      stepOrder=3  (wktStepIndex=2):  RepeatGroup container (4 iterations)
      stepOrder=4  (wktStepIndex=3):  interval inside repeat — cadence 150-200 spm
      stepOrder=5  (wktStepIndex=4):  recovery inside repeat — no target
      stepOrder=6  (wktStepIndex=5):  other, "Up next: Accel-Glider"
      stepOrder=7  (wktStepIndex=6):  RepeatGroup container (4 iterations)
      stepOrder=8  (wktStepIndex=7):  interval inside repeat — no target (accel-glider)
      stepOrder=9  (wktStepIndex=8):  other, "Up next: Speed Drill"
      stepOrder=10 (wktStepIndex=9):  RepeatGroup container (8 iterations)
      stepOrder=11 (wktStepIndex=10): interval inside repeat — pace.zone 3.538/3.389 m/s
      stepOrder=12 (wktStepIndex=11): recovery inside repeat — no target
      stepOrder=13 (wktStepIndex=12): COOLDOWN, 5min, no target

    wktStepIndex = stepOrder - 1 (0-based vs 1-based).
    Real splits confirm indices: 0,1,2,3,5,6,8,9,10,12 appear in lapDTOs.
    """

    def test_returns_dict(self, workout_def):
        result = build_step_target_map(workout_def)
        assert isinstance(result, dict)

    def test_warmup_step_keyed_at_index_0(self, workout_def):
        """stepOrder=1 → wktStepIndex=0 (warmup)."""
        result = build_step_target_map(workout_def)
        assert 0 in result

    def test_cooldown_step_keyed_at_index_12(self, workout_def):
        """stepOrder=13 → wktStepIndex=12 (cooldown)."""
        result = build_step_target_map(workout_def)
        assert 12 in result

    def test_pace_zone_step_has_slow_pace(self, workout_def):
        """stepOrder=11 (800m interval) → wktStepIndex=10, pace.zone target.

        Garmin targetValueTwo=3.3889971 m/s is the SLOWER end → more s/km.
        slow_s_per_km should be the higher value (≈295.1 s/km = 4:55/km).
        """
        result = build_step_target_map(workout_def)
        # targetValueTwo=3.3889971 m/s (slow end) → 1000/3.389 ≈ 295.1 s/km
        assert result[10]["target_pace_slow_s_per_km"] == pytest.approx(1000 / 3.3889971, abs=1.0)

    def test_pace_zone_step_has_fast_pace(self, workout_def):
        """stepOrder=11 (800m interval) → wktStepIndex=10, pace.zone fast end.

        Garmin targetValueOne=3.5380059 m/s is the FASTER end → fewer s/km.
        fast_s_per_km should be the lower value (≈282.6 s/km = 4:42/km).
        """
        result = build_step_target_map(workout_def)
        # targetValueOne=3.5380059 m/s (fast end) → 1000/3.538 ≈ 282.6 s/km
        assert result[10]["target_pace_fast_s_per_km"] == pytest.approx(1000 / 3.5380059, abs=1.0)

    def test_warmup_no_target_returns_none_for_pace(self, workout_def):
        """Warmup has targetTypeKey='no.target' → both pace fields None."""
        result = build_step_target_map(workout_def)
        assert result[0]["target_pace_slow_s_per_km"] is None
        assert result[0]["target_pace_fast_s_per_km"] is None

    def test_cadence_step_returns_none_for_pace(self, workout_def):
        """wktStepIndex=2 is the cadence RepeatGroup → maps to cadence target, not pace."""
        result = build_step_target_map(workout_def)
        # wktStepIndex=2 = RepeatGroup container (stepOrder=3), first child has cadence target
        assert result[2]["target_pace_slow_s_per_km"] is None
        assert result[2]["target_pace_fast_s_per_km"] is None

    def test_cadence_step_has_cadence_targets(self, workout_def):
        """wktStepIndex=2 (cadence RepeatGroup): first child has cadence 150-200 spm."""
        result = build_step_target_map(workout_def)
        # wktStepIndex=2 = RepeatGroup whose first child is the cadence drill step
        assert result[2]["target_cadence_low"] == pytest.approx(150.0)
        assert result[2]["target_cadence_high"] == pytest.approx(200.0)

    def test_repeat_group_steps_are_flattened(self, workout_def):
        """Steps nested inside RepeatGroupDTO must be included in the map."""
        result = build_step_target_map(workout_def)
        # stepOrder=12 (recovery inside 8x800m group) → wktStepIndex=11
        assert 11 in result

    def test_all_real_split_wkt_indices_present(self, workout_def):
        """All wktStepIndex values seen in real lap data must be in the map."""
        result = build_step_target_map(workout_def)
        # Real splits had these wktStepIndex values:
        real_indices = {0, 1, 2, 3, 5, 6, 8, 9, 10, 12}
        for idx in real_indices:
            assert idx in result, f"wktStepIndex={idx} missing from step target map"

    def test_step_type_key_preserved(self, workout_def):
        """step_type_key from stepType.stepTypeKey is stored per step."""
        result = build_step_target_map(workout_def)
        assert result[0]["step_type_key"] == "warmup"
        assert result[12]["step_type_key"] == "cooldown"

    def test_description_stored(self, workout_def):
        """Step description (drill instructions etc.) is stored."""
        result = build_step_target_map(workout_def)
        # stepOrder=4 (cadence drill) has a description
        assert result[3]["description"] is not None
        assert len(result[3]["description"]) > 0

    def test_non_pace_step_cadence_fields_none_when_not_cadence(self, workout_def):
        """Non-cadence steps have target_cadence_low/high = None."""
        result = build_step_target_map(workout_def)
        assert result[0]["target_cadence_low"] is None
        assert result[0]["target_cadence_high"] is None

    def test_empty_segments_returns_empty_dict(self):
        """Workout with no steps produces empty map."""
        workout = {"workoutSegments": [{"workoutSteps": []}]}
        result = build_step_target_map(workout)
        assert result == {}

    def test_missing_segments_key_returns_empty_dict(self):
        """Workout with no workoutSegments key produces empty map."""
        result = build_step_target_map({})
        assert result == {}
