"""Tests for Garmin API response normalizer.

Fixtures are captured from the real Garmin API using:
    python scripts/capture_fixtures.py

Re-run this script periodically (or after garminconnect upgrades) to ensure
the fixtures reflect the actual API response schema.

Schema notes captured from real API responses:

  get_activity_evaluation() → garmin_activity_summary.json:
    - activityTypeDTO (not activityType)
    - summaryDTO nests: startTimeGMT, startTimeLocal, duration, distance,
      averageHR, maxHR, averageSpeed, elevationGain, elevationLoss,
      trainingEffect, anaerobicTrainingEffect, averageRunCadence
    - Time format: "YYYY-MM-DDTHH:MM:SS.f" (ISO 8601 with T separator)
    - vO2MaxValue NOT present (only in get_activities() list items)

  get_activities() → garmin_activity_list_item.json:
    - activityType (not activityTypeDTO), flat structure
    - startTimeGMT, startTimeLocal at top level
    - Time format: "YYYY-MM-DD HH:MM:SS" (space-separated)
    - vO2MaxValue present at top level

  get_activity_splits() → garmin_activity_splits.json:
    - {"lapDTOs": [...]}  (top-level wrapper)
    - Each lapDTO: intensityType (WARMUP/ACTIVE/RECOVERY/COOLDOWN)
    - Fields: distance, duration, averageHR, averageSpeed, elevationGain
    - startTimeGMT is ISO 8601 absolute timestamp (not elapsed seconds)
"""
import json
from datetime import date, datetime
from pathlib import Path

import pytest

from fitness.garmin.normalizer import (
    normalize_activity_summary,
    normalize_sleep,
    normalize_hrv,
    normalize_typed_split,
)

FIXTURES = Path(__file__).parent.parent / "fixtures"


@pytest.fixture
def activity_summary():
    """Real response from get_activity_evaluation() — nested summaryDTO schema.

    Key differences from get_activities() list items:
    - activityTypeDTO (not activityType)
    - summaryDTO wraps performance data
    - ISO 8601 time format with T separator
    - vO2MaxValue not present
    """
    return json.loads((FIXTURES / "garmin_activity_summary.json").read_text())


@pytest.fixture
def activity_list_item():
    """Real response item from get_activities() list — flat schema.

    Generated by scripts/capture_fixtures.py. If the file is absent, these
    tests are skipped (run the capture script to generate it).
    """
    p = FIXTURES / "garmin_activity_list_item.json"
    if not p.exists():
        pytest.skip("garmin_activity_list_item.json not found — run scripts/capture_fixtures.py")
    return json.loads(p.read_text())


@pytest.fixture
def sleep_data():
    return json.loads((FIXTURES / "garmin_sleep.json").read_text())


@pytest.fixture
def hrv_data():
    return json.loads((FIXTURES / "garmin_hrv.json").read_text())


@pytest.fixture
def typed_splits():
    """Real lapDTOs from get_activity_splits() if available, else hand-crafted."""
    real = FIXTURES / "garmin_activity_splits.json"
    if real.exists():
        data = json.loads(real.read_text())
        # get_activity_splits returns {"lapDTOs": [...]}
        laps = data.get("lapDTOs", data) if isinstance(data, dict) else data
        return laps
    return json.loads((FIXTURES / "garmin_typed_splits.json").read_text())


# ─── Activity summary normalizer (get_activity_evaluation schema) ──────────────

class TestNormalizeActivitySummary:
    """Tests against real get_activity_evaluation() fixture (nested summaryDTO schema)."""

    def test_returns_dict(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        assert isinstance(result, dict)

    def test_garmin_activity_id_is_string(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # scrubbed fixture uses activityId 10000000001
        assert result["garmin_activity_id"] == "10000000001"

    def test_name_extracted(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # scrubbed fixture uses "Seattle - Speed Repeats"
        assert result["name"] == "Seattle - Speed Repeats"

    def test_activity_type_extracted(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # activityTypeDTO.typeKey = "running" in real fixture
        assert result["activity_type"] == "running"

    def test_start_time_is_datetime(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        assert isinstance(result["start_time_utc"], datetime)
        # summaryDTO.startTimeGMT = "2026-02-18T19:22:38.0"
        assert result["start_time_utc"].year == 2026
        assert result["start_time_utc"].hour == 19
        assert result["start_time_utc"].minute == 22

    def test_duration_seconds(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # summaryDTO.duration = 4313.975
        assert result["duration_seconds"] == pytest.approx(4313.975)

    def test_distance_meters(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # summaryDTO.distance = 10551.31
        assert result["distance_meters"] == pytest.approx(10551.31)

    def test_avg_hr(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # summaryDTO.averageHR = 133.0
        assert result["avg_hr"] == pytest.approx(133.0)

    def test_max_hr(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # summaryDTO.maxHR = 170.0
        assert result["max_hr"] == pytest.approx(170.0)

    def test_avg_pace_derived_from_speed(self, activity_summary):
        # summaryDTO.averageSpeed = 2.446000099 m/s → pace = 1000/2.446 ≈ 408.9 s/km
        result = normalize_activity_summary(activity_summary)
        assert result["avg_pace_seconds_per_km"] == pytest.approx(1000.0 / 2.446000099182129, abs=1.0)

    def test_elevation_gain_and_loss(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # summaryDTO.elevationGain = 15.48, elevationLoss = 16.23
        assert result["total_ascent_meters"] == pytest.approx(15.48)
        assert result["total_descent_meters"] == pytest.approx(16.23)

    def test_training_effect(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        # summaryDTO.trainingEffect = 4.1 (aerobic), anaerobicTrainingEffect = 0.1
        assert result["training_effect_aerobic"] == pytest.approx(4.1, abs=0.01)
        assert result["training_effect_anaerobic"] == pytest.approx(0.1, abs=0.01)

    def test_vo2max_is_none_for_evaluation_endpoint(self, activity_summary):
        """vO2MaxValue is only in get_activities() list items, not evaluation responses."""
        result = normalize_activity_summary(activity_summary)
        assert result["vo2max_estimated"] is None

    def test_weather_temp_is_none_when_absent(self, activity_summary):
        """Real fixture has no weatherTemperature field."""
        result = normalize_activity_summary(activity_summary)
        assert result["weather_temp_c"] is None

    def test_raw_summary_json_stored(self, activity_summary):
        result = normalize_activity_summary(activity_summary)
        stored = json.loads(result["raw_summary_json"])
        assert stored["activityId"] == activity_summary["activityId"]

    def test_missing_optional_fields_are_none(self):
        """Minimal flat dict (hand-crafted) — optional fields should be None."""
        minimal = {
            "activityId": 999,
            "activityName": "Run",
            "activityType": {"typeKey": "running"},
            "startTimeGMT": "2025-06-01 08:00:00",
            "duration": 1800.0,
            "distance": 5000.0,
        }
        result = normalize_activity_summary(minimal)
        assert result["avg_hr"] is None
        assert result["vo2max_estimated"] is None
        assert result["training_effect_aerobic"] is None
        assert result["weather_temp_c"] is None

    def test_start_time_from_startTimeLocal_when_startTimeGMT_absent(self):
        """get_activity_evaluation() returns startTimeLocal (nested in summaryDTO).

        The normalizer must handle both key names so that both get_activities()
        list items (startTimeGMT) and get_activity_evaluation() detail objects
        (startTimeLocal) can be normalised without KeyError.
        """
        raw = {
            "activityId": 999,
            "activityName": "Evening Run",
            "activityType": {"typeKey": "running"},
            "startTimeLocal": "2025-06-01 20:00:00",  # key from list endpoint
            "duration": 1800.0,
            "distance": 5000.0,
        }
        result = normalize_activity_summary(raw)
        assert isinstance(result["start_time_utc"], datetime)
        assert result["start_time_utc"].hour == 20

    def test_start_time_from_summaryDTO_startTimeLocal(self):
        """get_activity_evaluation() nests startTimeLocal inside summaryDTO."""
        raw = {
            "activityId": 999,
            "activityName": "Evening Run",
            "activityTypeDTO": {"typeKey": "running"},
            "summaryDTO": {
                "startTimeLocal": "2025-06-01T20:00:00.0",  # ISO 8601, nested
                "duration": 1800.0,
                "distance": 5000.0,
            },
        }
        result = normalize_activity_summary(raw)
        assert isinstance(result["start_time_utc"], datetime)
        assert result["start_time_utc"].hour == 20

    def test_start_time_prefers_startTimeGMT_over_startTimeLocal(self):
        """When both keys exist, startTimeGMT (true UTC) takes precedence."""
        raw = {
            "activityId": 999,
            "activityName": "Morning Run",
            "activityType": {"typeKey": "running"},
            "startTimeGMT": "2025-06-01 07:00:00",
            "startTimeLocal": "2025-06-01 09:00:00",  # local offset, should be ignored
            "duration": 1800.0,
            "distance": 5000.0,
        }
        result = normalize_activity_summary(raw)
        assert result["start_time_utc"].hour == 7

    def test_raises_key_error_when_neither_start_time_key_present(self):
        """Confirm a clear error when the response has no recognisable time field."""
        raw = {
            "activityId": 999,
            "activityName": "Run",
            "activityType": {"typeKey": "running"},
            "duration": 1800.0,
            "distance": 5000.0,
        }
        with pytest.raises(KeyError):
            normalize_activity_summary(raw)

    def test_iso_8601_datetime_parsed_correctly(self):
        """ISO 8601 format from get_activity_evaluation() is parsed correctly."""
        raw = {
            "activityId": 999,
            "activityName": "Run",
            "activityTypeDTO": {"typeKey": "running"},
            "summaryDTO": {
                "startTimeGMT": "2025-06-01T14:30:00.0",
                "duration": 1800.0,
                "distance": 5000.0,
            },
        }
        result = normalize_activity_summary(raw)
        assert result["start_time_utc"] == datetime(2025, 6, 1, 14, 30, 0)


# ─── Activity list item normalizer (uses startTimeGMT schema) ─────────────────

class TestNormalizeActivityListItem:
    """Tests against real get_activities() list item fixture (startTimeGMT schema).

    These tests are skipped if the fixture hasn't been captured yet.
    Run: python scripts/capture_fixtures.py
    """

    def test_returns_dict(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert isinstance(result, dict)

    def test_garmin_activity_id_is_string(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert isinstance(result["garmin_activity_id"], str)
        assert len(result["garmin_activity_id"]) > 0

    def test_activity_type_extracted(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert result["activity_type"] == "running"

    def test_start_time_is_datetime(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert isinstance(result["start_time_utc"], datetime)

    def test_start_time_uses_gmt_not_local(self, activity_list_item):
        """List items have both startTimeGMT and startTimeLocal; GMT should be used."""
        result = normalize_activity_summary(activity_list_item)
        # scrubbed fixture: startTimeGMT = "2026-02-18 19:22:38" (hour=19)
        # scrubbed fixture: startTimeLocal = "2026-02-18 11:22:38" (hour=11)
        assert result["start_time_utc"].hour == 19

    def test_duration_is_float(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert isinstance(result["duration_seconds"], float)
        assert result["duration_seconds"] > 0

    def test_distance_is_float(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert isinstance(result["distance_meters"], float)
        assert result["distance_meters"] > 0

    def test_vo2max_present_in_list_items(self, activity_list_item):
        """vO2MaxValue is present in get_activities() list items."""
        result = normalize_activity_summary(activity_list_item)
        # scrubbed fixture has vO2MaxValue = 46.0
        assert result["vo2max_estimated"] == pytest.approx(46.0)

    def test_avg_hr_extracted(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        assert result["avg_hr"] is not None
        assert result["avg_hr"] > 0

    def test_raw_json_round_trips(self, activity_list_item):
        result = normalize_activity_summary(activity_list_item)
        stored = json.loads(result["raw_summary_json"])
        assert stored["activityId"] == activity_list_item["activityId"]


# ─── Sleep normalizer ──────────────────────────────────────────────────────────

class TestNormalizeSleep:
    def test_returns_dict(self, sleep_data):
        result = normalize_sleep(sleep_data)
        assert isinstance(result, dict)

    def test_sleep_date_is_date(self, sleep_data):
        result = normalize_sleep(sleep_data)
        assert isinstance(result["sleep_date"], date)
        # real fixture: calendarDate = "2026-02-19"
        assert result["sleep_date"] == date(2026, 2, 19)

    def test_duration_seconds(self, sleep_data):
        result = normalize_sleep(sleep_data)
        # real fixture: sleepTimeSeconds = 26280
        assert result["duration_seconds"] == 26280

    def test_sleep_stages(self, sleep_data):
        result = normalize_sleep(sleep_data)
        # real fixture values
        assert result["deep_sleep_seconds"] == 6720
        assert result["light_sleep_seconds"] == 14100
        assert result["rem_sleep_seconds"] == 5460
        assert result["awake_seconds"] == 2340

    def test_sleep_score_is_none_when_absent(self, sleep_data):
        """Real fixture has sleepScores: null — score should be None."""
        result = normalize_sleep(sleep_data)
        assert result["sleep_score"] is None

    def test_raw_json_stored(self, sleep_data):
        result = normalize_sleep(sleep_data)
        assert result["raw_json"] is not None
        stored = json.loads(result["raw_json"])
        assert "dailySleepDTO" in stored

    def test_sleep_score_extracted_when_nested(self):
        """When sleepScores.overall.value is present, it should be extracted."""
        raw = {
            "dailySleepDTO": {
                "calendarDate": "2025-01-15",
                "sleepTimeSeconds": 24000,
                "deepSleepSeconds": 4200,
                "lightSleepSeconds": 10800,
                "remSleepSeconds": 7200,
                "awakeSleepSeconds": 1800,
                "sleepScores": {"overall": {"value": 71}},
                "averageSpO2Value": 96.5,
            }
        }
        result = normalize_sleep(raw)
        assert result["sleep_score"] == 71
        assert result["avg_spo2"] == pytest.approx(96.5)
        assert result["sleep_date"] == date(2025, 1, 15)
        assert result["duration_seconds"] == 24000
        assert result["deep_sleep_seconds"] == 4200
        assert result["light_sleep_seconds"] == 10800
        assert result["rem_sleep_seconds"] == 7200
        assert result["awake_seconds"] == 1800


# ─── HRV normalizer ───────────────────────────────────────────────────────────

class TestNormalizeHRV:
    """HRV fixture may be null (no data captured). Tests use hand-crafted data."""

    def test_returns_dict(self):
        raw = {
            "hrvSummary": {
                "startTimestampGMT": "2025-01-15T08:00:00",
                "weeklyAvg": 58.0,
                "lastNight": 52.0,
                "status": "BALANCED",
            }
        }
        result = normalize_hrv(raw)
        assert isinstance(result, dict)

    def test_record_date(self):
        raw = {
            "hrvSummary": {
                "startTimestampGMT": "2025-01-15T08:00:00",
                "weeklyAvg": 58.0,
                "lastNight": 52.0,
                "status": "BALANCED",
            }
        }
        result = normalize_hrv(raw)
        assert isinstance(result["record_date"], date)
        assert result["record_date"] == date(2025, 1, 15)

    def test_weekly_avg_hrv(self):
        raw = {
            "hrvSummary": {
                "startTimestampGMT": "2025-01-15T08:00:00",
                "weeklyAvg": 58.0,
                "lastNight": 52.0,
                "status": "BALANCED",
            }
        }
        result = normalize_hrv(raw)
        assert result["weekly_avg_hrv"] == pytest.approx(58.0)

    def test_last_night_hrv(self):
        raw = {
            "hrvSummary": {
                "startTimestampGMT": "2025-01-15T08:00:00",
                "weeklyAvg": 58.0,
                "lastNight": 52.0,
                "status": "BALANCED",
            }
        }
        result = normalize_hrv(raw)
        assert result["last_night_avg_hrv"] == pytest.approx(52.0)

    def test_status(self):
        raw = {
            "hrvSummary": {
                "startTimestampGMT": "2025-01-15T08:00:00",
                "weeklyAvg": 58.0,
                "lastNight": 52.0,
                "status": "BALANCED",
            }
        }
        result = normalize_hrv(raw)
        assert result["status"] == "BALANCED"

    def test_raw_json_stored(self):
        raw = {
            "hrvSummary": {
                "startTimestampGMT": "2025-01-15T08:00:00",
                "weeklyAvg": 58.0,
                "lastNight": 52.0,
                "status": "BALANCED",
            }
        }
        result = normalize_hrv(raw)
        assert result["raw_json"] is not None


# ─── Typed split normalizer (real lapDTOs schema) ─────────────────────────────

class TestNormalizeTypedSplit:
    """Tests against real lapDTOs from get_activity_splits().

    Real fixture schema (lapDTOs):
      - intensityType: "WARMUP" | "ACTIVE" | "RECOVERY" | "COOLDOWN"
      - laps[0]: WARMUP   → split_type "run_segment"
      - laps[1]: ACTIVE   → split_type "run_segment"
      - laps[3]: RECOVERY → split_type "walk_segment"
      - Fields: distance, duration, averageHR, averageSpeed, elevationGain
      - startTimeGMT: ISO 8601 absolute timestamp (elapsed computed by caller)

    Note: split_type mapping follows workout intent:
      WARMUP/ACTIVE → run_segment
      RECOVERY/COOLDOWN → walk_segment
    """

    def test_warmup_maps_to_run_segment(self, typed_splits):
        """laps[0] is WARMUP → treated as run_segment (still running pace)."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        assert result["split_type"] == "run_segment"

    def test_active_maps_to_run_segment(self, typed_splits):
        """laps[1] is ACTIVE → run_segment."""
        result = normalize_typed_split(typed_splits[1], split_index=1)
        assert result["split_type"] == "run_segment"

    def test_recovery_maps_to_walk_segment(self, typed_splits):
        """laps[3] is RECOVERY → walk_segment."""
        result = normalize_typed_split(typed_splits[3], split_index=3)
        assert result["split_type"] == "walk_segment"

    def test_split_index(self, typed_splits):
        result = normalize_typed_split(typed_splits[0], split_index=0)
        assert result["split_index"] == 0

    def test_split_index_preserved(self, typed_splits):
        result = normalize_typed_split(typed_splits[3], split_index=3)
        assert result["split_index"] == 3

    def test_duration_seconds_warmup(self, typed_splits):
        """laps[0] WARMUP duration = 300.0 seconds."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        assert result["duration_seconds"] == pytest.approx(300.0)

    def test_distance_meters_warmup(self, typed_splits):
        """laps[0] WARMUP distance = 832.69 meters."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        assert result["distance_meters"] == pytest.approx(832.69, abs=0.1)

    def test_avg_hr_warmup(self, typed_splits):
        """laps[0] WARMUP averageHR = 127.0."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        assert result["avg_hr"] == pytest.approx(127.0)

    def test_avg_pace_derived_from_speed(self, typed_splits):
        """laps[0] WARMUP averageSpeed ≈ 2.776 m/s → pace ≈ 360 s/km."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        # 1000 / 2.776 ≈ 360.2 s/km
        assert result["avg_pace_seconds_per_km"] == pytest.approx(360.2, abs=2.0)

    def test_elevation_gain_extracted(self, typed_splits):
        """elevationGain is stored in total_ascent_meters when present."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        # warmup lap has elevationGain field
        assert "total_ascent_meters" in result

    def test_start_elapsed_seconds_zero_without_activity_start(self, typed_splits):
        """normalize_typed_split doesn't know activity start time.

        start_elapsed_seconds will be 0 unless a startTime field is present
        in the lapDTO (it's not in real lapDTOs — the caller must derive it
        from startTimeGMT vs activity startTimeGMT).
        """
        result = normalize_typed_split(typed_splits[0], split_index=0)
        assert result["start_elapsed_seconds"] == 0

    def test_unknown_intensity_maps_to_lap(self, typed_splits):
        """Unrecognised intensityType falls back to 'lap'."""
        raw = dict(typed_splits[0])
        raw["intensityType"] = "UNKNOWN_TYPE"
        result = normalize_typed_split(raw, split_index=99)
        assert result["split_type"] == "lap"

    def test_all_required_keys_present(self, typed_splits):
        """Normalizer always returns all required ActivitySplit field keys."""
        result = normalize_typed_split(typed_splits[0], split_index=0)
        required_keys = {
            "split_index",
            "split_type",
            "start_elapsed_seconds",
            "duration_seconds",
            "distance_meters",
            "avg_hr",
            "avg_pace_seconds_per_km",
            "total_ascent_meters",
        }
        assert required_keys.issubset(result.keys())
